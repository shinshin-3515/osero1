<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Maze (Three.js)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#000; }
    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font: 14px/1.4 system-ui, -apple-system, Segoe UI, sans-serif;
      background: rgba(0,0,0,.45); padding: 10px 12px; border-radius: 10px;
      user-select: none;
    }
    #hud b { font-weight: 700; }
    #reticle {
      position: fixed; left: 50%; top: 50%; width: 10px; height: 10px;
      margin-left: -5px; margin-top: -5px; z-index: 9;
      border: 2px solid rgba(255,255,255,.8); border-radius: 50%;
      pointer-events: none;
    }
    #msg {
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      color:#fff; font: 13px system-ui; background: rgba(0,0,0,.5);
      padding: 8px 12px; border-radius: 10px; z-index: 10;
    }
    a { color:#9fd; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>3D Maze</b> / クリックして視点ロック</div>
    <div>移動: <b>WASD</b>　ジャンプ: <b>Space</b>　走る: <b>Shift</b></div>
    <div>視点: <b>Mouse</b>　解除: <b>Esc</b>　リセット: <b>R</b></div>
    <div>ゴール: 緑の柱に触れる</div>
  </div>
  <div id="reticle"></div>
  <div id="msg">ロード中…</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

    const msgEl = document.getElementById("msg");
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0f1a, 10, 80);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 300);
    camera.position.set(0, 1.7, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(12, 18, 8);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    // Ground
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a2233, roughness: 1 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Simple maze generator (grid walls)
    const gridW = 16, gridH = 16;
    const cellSize = 4;
    const wallH = 3;

    // 0=empty, 1=wall
    const map = [];
    for (let y=0; y<gridH; y++) {
      map[y] = [];
      for (let x=0; x<gridW; x++) {
        // border walls + some random interior walls
        const border = (x===0||y===0||x===gridW-1||y===gridH-1);
        const randomWall = (!border && Math.random() < 0.22 && !(x===1&&y===1) && !(x===gridW-2&&y===gridH-2));
        map[y][x] = (border || randomWall) ? 1 : 0;
      }
    }
    // Ensure a basic corridor path: clear diagonal-ish
    for (let i=1; i<gridW-1; i++) map[i][i] = 0;

    const wallGeo = new THREE.BoxGeometry(cellSize, wallH, cellSize);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x3a516b, roughness: 0.9, metalness: 0.05 });

    const colliders = []; // AABBs for collision
    const wallsGroup = new THREE.Group();
    scene.add(wallsGroup);

    function addWall(x, y) {
      const m = new THREE.Mesh(wallGeo, wallMat);
      m.position.set(x*cellSize, wallH/2, y*cellSize);
      m.castShadow = true; m.receiveShadow = true;
      wallsGroup.add(m);

      // collider AABB
      const half = cellSize/2;
      colliders.push({
        min: new THREE.Vector3(m.position.x-half, 0, m.position.z-half),
        max: new THREE.Vector3(m.position.x+half, wallH, m.position.z+half),
      });
    }

    for (let y=0; y<gridH; y++) {
      for (let x=0; x<gridW; x++) {
        if (map[y][x] === 1) addWall(x, y);
      }
    }

    // Goal
    const goal = new THREE.Mesh(
      new THREE.CylinderGeometry(0.6, 0.6, 2.5, 16),
      new THREE.MeshStandardMaterial({ color: 0x44ff88, emissive: 0x0a2a12 })
    );
    goal.position.set((gridW-2)*cellSize, 1.25, (gridH-2)*cellSize);
    goal.castShadow = true;
    scene.add(goal);

    // Controls
    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener("click", () => controls.lock());
    controls.addEventListener("lock", () => msgEl.textContent = "プレイ中：ゴール（緑の柱）を目指せ！");
    controls.addEventListener("unlock", () => msgEl.textContent = "クリックで再開（Escで解除）");
    scene.add(controls.getObject());

    const keys = new Set();
    addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (e.code === "KeyR") resetPlayer();
    });
    addEventListener("keyup", (e) => keys.delete(e.code));

    function resetPlayer(){
      velocity.set(0,0,0);
      playerPos.set(cellSize*1, 1.7, cellSize*1);
      controls.getObject().position.copy(playerPos);
      msgEl.textContent = "リセットしました";
    }

    // Player physics (capsule-ish using radius in XZ, height in Y)
    const playerPos = new THREE.Vector3(cellSize*1, 1.7, cellSize*1);
    const velocity = new THREE.Vector3();
    const radius = 0.5;
    const gravity = -18;
    let onGround = false;

    // For collision: clamp sphere center against AABB in XZ, and ground plane in Y
    function resolveCollisions(pos) {
      // ground
      if (pos.y < 1.7) { pos.y = 1.7; velocity.y = 0; onGround = true; }
      else onGround = false;

      // walls
      for (const b of colliders) {
        // nearest point on AABB to player (in XZ, keep Y within [0, wallH])
        const nx = Math.max(b.min.x, Math.min(pos.x, b.max.x));
        const nz = Math.max(b.min.z, Math.min(pos.z, b.max.z));
        const dx = pos.x - nx;
        const dz = pos.z - nz;
        const dist2 = dx*dx + dz*dz;
        if (dist2 < radius*radius) {
          const dist = Math.sqrt(dist2) || 0.0001;
          const push = (radius - dist);
          pos.x += (dx / dist) * push;
          pos.z += (dz / dist) * push;
        }
      }
    }

    // Mini skybox-ish gradient
    renderer.setClearColor(0x0a0f1a);

    // Animation
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.033);
      last = now;

      if (controls.isLocked) {
        const speed = (keys.has("ShiftLeft") || keys.has("ShiftRight")) ? 8 : 4.5;

        // movement direction in camera space
        const forward = new THREE.Vector3();
        controls.getDirection(forward);
        forward.y = 0; forward.normalize();

        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

        const move = new THREE.Vector3();
        if (keys.has("KeyW")) move.add(forward);
        if (keys.has("KeyS")) move.sub(forward);
        if (keys.has("KeyD")) move.add(right);
        if (keys.has("KeyA")) move.sub(right);
        if (move.lengthSq() > 0) move.normalize().multiplyScalar(speed);

        // simple accel
        velocity.x = move.x;
        velocity.z = move.z;

        // jump
        if (keys.has("Space") && onGround) {
          velocity.y = 7.5;
          onGround = false;
        }

        // gravity
        velocity.y += gravity * dt;

        // integrate
        playerPos.x += velocity.x * dt;
        playerPos.y += velocity.y * dt;
        playerPos.z += velocity.z * dt;

        resolveCollisions(playerPos);
        controls.getObject().position.copy(playerPos);

        // goal check
        if (playerPos.distanceTo(goal.position) < 1.2) {
          msgEl.textContent = "クリア！ Rでリスタート / クリックで続行";
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    resetPlayer();
    msgEl.textContent = "クリックで開始（視点ロック）";
    requestAnimationFrame(tick);

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
