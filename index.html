<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>CPU対戦オセロ</title>
<style>
  :root{
    --bg:#0b1220; --panel:#111a2e; --board:#0f3a2d; --line:#0a2a21;
    --text:#e6eefc; --muted:#a9b6d6; --accent:#6aa7ff; --warn:#ffb86a;
    --cell:40px; /* JSで上書き */
  }
  body{
    margin:0; font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", sans-serif;
    background:linear-gradient(180deg, #070b14, var(--bg));
    color:var(--text);
    padding: max(12px, env(safe-area-inset-top)) 12px max(12px, env(safe-area-inset-bottom));
  }
  h1{ font-size:18px; margin:6px 0 10px; letter-spacing: .02em; }
  .wrap{ max-width: 560px; margin:0 auto; }
  .panel{
    background: rgba(17,26,46,.88);
    border: 1px solid rgba(255,255,255,.08);
    border-radius: 14px;
    padding: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .row > *{ flex: 1 1 auto; }
  .stat{
    display:flex; justify-content:space-between; gap:10px; font-size:14px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    padding:10px 12px; border-radius:12px;
  }
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding:8px 10px; border-radius:12px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    font-size:14px;
  }
  select, button{
    -webkit-tap-highlight-color: transparent;
    appearance:none;
    background: rgba(0,0,0,.18);
    color: var(--text);
    border:1px solid rgba(255,255,255,.14);
    border-radius: 12px;
    padding: 10px 12px;
    font-size: 14px;
  }
  button{
    cursor:pointer;
    background: linear-gradient(180deg, rgba(106,167,255,.18), rgba(0,0,0,.18));
    border-color: rgba(106,167,255,.35);
  }
  button:active{ transform: translateY(1px); }
  .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.5; }
  .msg{ margin-top:10px; font-size:14px; color: var(--text); }
  .msg small{ color:var(--muted); }
  .boardWrap{ margin-top:12px; display:flex; justify-content:center; }
  canvas{
    border-radius: 14px;
    background: radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.10), rgba(0,0,0,.00)), var(--board);
    border: 1px solid rgba(255,255,255,.10);
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
    touch-action: manipulation;
  }
  .legend{
    display:flex; gap:10px; justify-content:space-between; margin-top:10px; flex-wrap:wrap;
  }
  .chip{
    display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted);
  }
  .dot{
    width:14px; height:14px; border-radius:50%;
    border:1px solid rgba(255,255,255,.16);
  }
  .dot.black{ background:#0b0f14; }
  .dot.white{ background:#f2f6ff; }
  .dot.hint{ background: rgba(106,167,255,.55); }
</style>
</head>
<body>
<div class="wrap">
  <h1>CPU対戦オセロ（iPhone対応）</h1>
  <div class="panel">
    <div class="row">
      <div class="pill">
        あなた：
        <select id="playerColor">
          <option value="BLACK" selected>黒（先手）</option>
          <option value="WHITE">白（後手）</option>
        </select>
      </div>
      <div class="pill">
        CPU強さ：
        <select id="aiLevel">
          <option value="0">やさしい</option>
          <option value="1" selected>ふつう</option>
          <option value="2">つよい</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="newGame">新しいゲーム</button>
      <button id="undo">1手戻す</button>
      <button id="toggleHints">置ける場所：表示</button>
    </div>

    <div class="row" style="margin-top:10px">
      <div class="stat"><span>黒</span><b id="blackCount">2</b></div>
      <div class="stat"><span>白</span><b id="whiteCount">2</b></div>
      <div class="stat"><span>手番</span><b id="turnLabel">黒</b></div>
    </div>

    <div class="msg" id="message">あなたの手番です。</div>
    <div class="hint">
      操作：マスをタップして置く。<br/>
      CPUは自動で打ちます。置ける場所がない場合は自動でパスします。<br/>
      「つよい」は先読み＋終盤重視で少し考えます（iPhoneでも軽め）。
    </div>

    <div class="boardWrap">
      <canvas id="cv" width="360" height="360"></canvas>
    </div>

    <div class="legend">
      <div class="chip"><span class="dot black"></span>黒</div>
      <div class="chip"><span class="dot white"></span>白</div>
      <div class="chip"><span class="dot hint"></span>置ける場所（ヒント）</div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== 定数 ======
  const EMPTY=0, BLACK=1, WHITE=2;
  const DIRS = [
    [-1,-1], [0,-1], [1,-1],
    [-1, 0],         [1, 0],
    [-1, 1], [0, 1], [1, 1],
  ];

  // 角・辺を強く、危険マス(X/C)を嫌う
  const W_POS = [
    [120,-20, 20,  5,  5, 20,-20,120],
    [-20,-40, -5, -5, -5, -5,-40,-20],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [  5, -5,  3,  3,  3,  3, -5,  5],
    [ 20, -5, 15,  3,  3, 15, -5, 20],
    [-20,-40, -5, -5, -5, -5,-40,-20],
    [120,-20, 20,  5,  5, 20,-20,120],
  ];

  // ====== 状態 ======
  let board, turn, humanColor, aiColor;
  let showHints = true;
  let history = []; // {board, turn}

  // UI
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const blackCountEl = document.getElementById("blackCount");
  const whiteCountEl = document.getElementById("whiteCount");
  const turnLabelEl  = document.getElementById("turnLabel");
  const msgEl = document.getElementById("message");
  const playerColorSel = document.getElementById("playerColor");
  const aiLevelSel = document.getElementById("aiLevel");
  const newGameBtn = document.getElementById("newGame");
  const undoBtn = document.getElementById("undo");
  const toggleHintsBtn = document.getElementById("toggleHints");

  // ====== 初期化 ======
  function initBoard() {
    board = Array.from({length:8}, () => Array(8).fill(EMPTY));
    board[3][3]=WHITE; board[4][4]=WHITE;
    board[3][4]=BLACK; board[4][3]=BLACK;
    turn = BLACK;
    history = [];
    pushHistory();
  }

  function pushHistory(){
    history.push({
      board: board.map(r => r.slice()),
      turn
    });
    if(history.length>200) history.shift();
  }

  function popHistory(){
    if(history.length<=1) return false;
    history.pop();
    const last = history[history.length-1];
    board = last.board.map(r => r.slice());
    turn = last.turn;
    return true;
  }

  function setColors() {
    humanColor = (playerColorSel.value === "BLACK") ? BLACK : WHITE;
    aiColor = (humanColor===BLACK) ? WHITE : BLACK;
  }

  // Canvas size fit for iPhone
  function fitCanvas(){
    const w = Math.min(window.innerWidth - 24, 560);
    const size = Math.max(300, Math.min(440, w));
    cv.width = cv.height = size;
    document.documentElement.style.setProperty("--cell", (size/8)+"px");
  }

  // ====== ルール処理 ======
  function inBounds(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
  function opponent(c){ return c===BLACK ? WHITE : BLACK; }

  function flipsForMove(b, x, y, color){
    if(!inBounds(x,y) || b[y][x]!==EMPTY) return [];
    const opp = opponent(color);
    let flips = [];
    for(const [dx,dy] of DIRS){
      let cx=x+dx, cy=y+dy;
      let line = [];
      while(inBounds(cx,cy) && b[cy][cx]===opp){
        line.push([cx,cy]);
        cx+=dx; cy+=dy;
      }
      if(line.length>0 && inBounds(cx,cy) && b[cy][cx]===color){
        flips = flips.concat(line);
      }
    }
    return flips;
  }

  function validMoves(b, color){
    const moves = [];
    for(let y=0;y<8;y++){
      for(let x=0;x<8;x++){
        const flips = flipsForMove(b,x,y,color);
        if(flips.length) moves.push({x,y,flips});
      }
    }
    return moves;
  }

  function applyMove(b, move, color){
    const nb = b.map(r=>r.slice());
    nb[move.y][move.x]=color;
    for(const [fx,fy] of move.flips) nb[fy][fx]=color;
    return nb;
  }

  function countDiscs(b){
    let bc=0,wc=0;
    for(const row of b){
      for(const c of row){
        if(c===BLACK) bc++;
        else if(c===WHITE) wc++;
      }
    }
    return {bc,wc};
  }

  function gameOver(b){
    return validMoves(b,BLACK).length===0 && validMoves(b,WHITE).length===0;
  }

  // ====== 評価関数（AI） ======
  function evaluate(b, color){
    const opp = opponent(color);

    // 位置価値
    let pos=0;
    for(let y=0;y<8;y++){
      for(let x=0;x<8;x++){
        if(b[y][x]===color) pos += W_POS[y][x];
        else if(b[y][x]===opp) pos -= W_POS[y][x];
      }
    }

    // モビリティ（打てる手の数）
    const myM = validMoves(b,color).length;
    const opM = validMoves(b,opp).length;
    const mob = (myM - opM) * 8;

    // ディスク差（序盤は軽め、終盤は重め）
    const {bc,wc} = countDiscs(b);
    const discDiff = (color===BLACK ? (bc-wc) : (wc-bc));

    // 盤面の埋まり具合
    const filled = bc+wc;
    const endWeight = (filled>=54) ? 6 : (filled>=44 ? 3 : 1);

    // 角の確保
    const corners = [[0,0],[7,0],[0,7],[7,7]];
    let cornerScore=0;
    for(const [x,y] of corners){
      if(b[y][x]===color) cornerScore += 50;
      else if(b[y][x]===opp) cornerScore -= 50;
    }

    return pos + mob + cornerScore + discDiff*endWeight;
  }

  function pickMoveEasy(moves){
    // 角があれば角優先、なければひっくり返し枚数最大
    let best = null, bestScore = -1e9;
    for(const m of moves){
      const isCorner = ( (m.x===0||m.x===7) && (m.y===0||m.y===7) );
      const score = (isCorner ? 10000 : 0) + m.flips.length;
      if(score>bestScore){ bestScore=score; best=m; }
    }
    return best;
  }

  function pickMoveNormal(b, moves, color){
    // 1手読み：評価最大（相手の返しをざっくり織り込む）
    let best=null, bestScore=-1e9;
    for(const m of moves){
      const nb = applyMove(b,m,color);
      // 相手の最善手を1手だけ見て減点
      const opp = opponent(color);
      const opMoves = validMoves(nb, opp);
      let penalty = 0;
      if(opMoves.length){
        let worstForMe = -1e9;
        for(const om of opMoves){
          const nb2 = applyMove(nb, om, opp);
          const s = evaluate(nb2, color);
          if(s>worstForMe) worstForMe = s;
        }
        penalty = (evaluate(nb, color) - worstForMe) * 0.9;
      }
      const score = evaluate(nb, color) - penalty;
      if(score>bestScore){ bestScore=score; best=m; }
    }
    return best;
  }

  function minimax(b, color, depth, alpha, beta){
    const opp = opponent(color);
    if(depth===0 || gameOver(b)){
      return {score: evaluate(b, aiColor)};
    }
    const moves = validMoves(b, color);
    if(moves.length===0){
      // パス
      return minimax(b, opp, depth-1, alpha, beta);
    }

    const maximizing = (color===aiColor);
    let bestMove=null;

    if(maximizing){
      let best=-1e9;
      for(const m of orderMoves(b, moves, color)){
        const nb = applyMove(b,m,color);
        const r = minimax(nb, opp, depth-1, alpha, beta).score;
        if(r>best){ best=r; bestMove=m; }
        alpha = Math.max(alpha, best);
        if(beta<=alpha) break;
      }
      return {score: best, move: bestMove};
    }else{
      let best=1e9;
      for(const m of orderMoves(b, moves, color)){
        const nb = applyMove(b,m,color);
        const r = minimax(nb, opp, depth-1, alpha, beta).score;
        if(r<best){ best=r; bestMove=m; }
        beta = Math.min(beta, best);
        if(beta<=alpha) break;
      }
      return {score: best, move: bestMove};
    }
  }

  function orderMoves(b, moves, color){
    // 角優先＋評価でソート（枝刈り効率UP）
    const opp = opponent(color);
    return moves
      .map(m=>{
        const nb = applyMove(b,m,color);
        const corner = ((m.x===0||m.x===7) && (m.y===0||m.y===7)) ? 20000 : 0;
        const score = corner + evaluate(nb, color) - validMoves(nb, opp).length*2;
        return {m, score};
      })
      .sort((a,b)=>b.score-a.score)
      .map(o=>o.m);
  }

  async function aiMoveIfNeeded(){
    if(turn!==aiColor) return;
    if(gameOver(board)) { finishGame(); return; }

    const moves = validMoves(board, aiColor);
    if(moves.length===0){
      // パス
      turn = humanColor;
      updateUI("CPUはパスしました。あなたの手番です。");
      // 連続パス/終了判定
      if(gameOver(board)) finishGame();
      return;
    }

    updateUI("CPU思考中…");
    await sleep(180); // iPhoneで「考えてる感」

    const level = Number(aiLevelSel.value);
    let chosen;
    if(level===0){
      chosen = pickMoveEasy(moves);
    }else if(level===1){
      chosen = pickMoveNormal(board, moves, aiColor);
    }else{
      // 強い：深さ2〜4を局面で可変（軽め）
      const {bc,wc} = countDiscs(board);
      const filled = bc+wc;
      const depth = (filled<20) ? 2 : (filled<44 ? 3 : 4);
      chosen = minimax(board, aiColor, depth, -1e9, 1e9).move || pickMoveNormal(board, moves, aiColor);
    }

    board = applyMove(board, chosen, aiColor);
    turn = humanColor;
    pushHistory();
    updateUI(`CPUが ${posName(chosen.x, chosen.y)} に置きました。あなたの手番です。`);

    // 人間が置けないなら自動パス
    autoPassIfNeeded();
  }

  function autoPassIfNeeded(){
    if(gameOver(board)) { finishGame(); return; }

    const humanMoves = validMoves(board, humanColor);
    if(turn===humanColor && humanMoves.length===0){
      turn = aiColor;
      updateUI("あなたは置ける場所がないのでパスです。CPUの手番。");
      // CPUも置けないなら終了
      if(gameOver(board)) { finishGame(); return; }
      aiMoveIfNeeded();
    }
  }

  function finishGame(){
    const {bc,wc} = countDiscs(board);
    let result = "";
    if(bc>wc) result = "黒の勝ち！";
    else if(wc>bc) result = "白の勝ち！";
    else result = "引き分け！";
    updateUI(`ゲーム終了：${result}（黒 ${bc} / 白 ${wc}）`);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  // ====== 描画 ======
  function draw(){
    const size = cv.width;
    const cell = size/8;
    ctx.clearRect(0,0,size,size);

    // グリッド
    ctx.lineWidth = Math.max(1, Math.floor(size/360));
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    for(let i=0;i<=8;i++){
      const p = i*cell;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,size); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(size,p); ctx.stroke();
    }

    // ヒント
    if(showHints){
      const moves = validMoves(board, turn);
      for(const m of moves){
        const cx = (m.x+0.5)*cell, cy=(m.y+0.5)*cell;
        ctx.beginPath();
        ctx.fillStyle = "rgba(106,167,255,.55)";
        ctx.arc(cx,cy, cell*0.10, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 石
    for(let y=0;y<8;y++){
      for(let x=0;x<8;x++){
        const v = board[y][x];
        if(v===EMPTY) continue;
        const cx=(x+0.5)*cell, cy=(y+0.5)*cell;
        const r = cell*0.38;

        // 影
        ctx.beginPath();
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.arc(cx, cy+r*0.06, r*1.02, 0, Math.PI*2);
        ctx.fill();

        // 本体（簡易グラデ）
        const grad = ctx.createRadialGradient(cx-r*0.35, cy-r*0.35, r*0.2, cx, cy, r*1.1);
        if(v===BLACK){
          grad.addColorStop(0, "rgba(70,90,120,.55)");
          grad.addColorStop(1, "rgba(8,12,16,1)");
        }else{
          grad.addColorStop(0, "rgba(255,255,255,1)");
          grad.addColorStop(1, "rgba(200,210,230,1)");
        }
        ctx.beginPath();
        ctx.fillStyle = grad;
        ctx.arc(cx,cy,r,0,Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.arc(cx,cy,r,0,Math.PI*2);
        ctx.stroke();
      }
    }

    // 最初の4点をわかりやすく（薄く）
    if(isInitial(board)){
      ctx.fillStyle="rgba(255,255,255,.06)";
      ctx.fillRect(3*cell,3*cell,2*cell,2*cell);
    }
  }

  function isInitial(b){
    const {bc,wc}=countDiscs(b);
    return bc===2 && wc===2;
  }

  function posName(x,y){
    // A1..H8（A=左、1=上）
    const col = "ABCDEFGH"[x];
    const row = (y+1);
    return `${col}${row}`;
  }

  // ====== UI更新 ======
  function updateUI(message){
    const {bc,wc} = countDiscs(board);
    blackCountEl.textContent = bc;
    whiteCountEl.textContent = wc;
    turnLabelEl.textContent = (turn===BLACK) ? "黒" : "白";

    // メッセージ
    msgEl.textContent = message || ((turn===humanColor) ? "あなたの手番です。" : "CPU思考中…");
    draw();

    // 終了判定
    if(gameOver(board)){
      // finishGame()は別で呼ぶが、ここで補助
      const {bc,wc}=countDiscs(board);
      if(bc+wc===64 || (validMoves(board,BLACK).length===0 && validMoves(board,WHITE).length===0)){
        // 何もしない
      }
    }
  }

  // ====== 入力（タップ） ======
  function canvasToCell(clientX, clientY){
    const rect = cv.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const cell = cv.width/8;
    const cx = Math.floor(x / (rect.width/8));
    const cy = Math.floor(y / (rect.height/8));
    // rectの比率ズレ対策
    return {x: Math.max(0, Math.min(7, cx)), y: Math.max(0, Math.min(7, cy))};
  }

  function handleTap(ev){
    ev.preventDefault();
    if(turn !== humanColor) return;
    if(gameOver(board)) return;

    const touch = ev.changedTouches ? ev.changedTouches[0] : ev;
    const {x,y} = canvasToCell(touch.clientX, touch.clientY);

    const flips = flipsForMove(board,x,y,humanColor);
    if(!flips.length){
      updateUI("そこには置けません。置ける場所（青点）をタップしてね。");
      return;
    }

    // 手を適用
    const move = {x,y,flips};
    board = applyMove(board, move, humanColor);
    turn = aiColor;
    pushHistory();
    updateUI(`あなたが ${posName(x,y)} に置きました。CPUの手番。`);

    // CPUも置けないなら終了/パス処理
    if(gameOver(board)) { finishGame(); return; }

    // CPUが置けないなら自動パスして人へ
    const aiMoves = validMoves(board, aiColor);
    if(aiMoves.length===0){
      turn = humanColor;
      updateUI("CPUは置ける場所がないのでパスです。あなたの手番。");
      autoPassIfNeeded();
      return;
    }

    aiMoveIfNeeded();
  }

  // ====== ボタン ======
  newGameBtn.addEventListener("click", () => {
    setColors();
    initBoard();
    updateUI("新しいゲームを開始しました。");
    // 人間が白（後手）ならCPUから
    if(turn===aiColor) aiMoveIfNeeded();
  });

  undoBtn.addEventListener("click", () => {
    // 「1手戻す」= 人間+CPUの1ターン分戻したいなら2回popする
    // ここでは分かりやすく「直前の状態へ」戻す（CPU直後でもOK）
    const ok = popHistory();
    if(!ok){
      updateUI("これ以上戻せません。");
      return;
    }
    // 盤面復元済
    updateUI("1手戻しました。");
    // 復元後、手番がCPUならそのまま打たせる（連打防止のため少し待つ）
    if(turn===aiColor) aiMoveIfNeeded();
  });

  toggleHintsBtn.addEventListener("click", () => {
    showHints = !showHints;
    toggleHintsBtn.textContent = "置ける場所：" + (showHints ? "表示" : "非表示");
    updateUI(showHints ? "ヒントを表示します。" : "ヒントを非表示にしました。");
  });

  playerColorSel.addEventListener("change", () => {
    setColors();
    // 途中変更は混乱するので新規開始を促す
    updateUI("先手/後手を変えました。『新しいゲーム』で反映されます。");
  });

  // タップ/クリック
  cv.addEventListener("touchend", handleTap, {passive:false});
  cv.addEventListener("click", handleTap);

  // ====== 起動 ======
  function start(){
    fitCanvas();
    setColors();
    initBoard();
    updateUI("あなたの手番です。");
    if(turn===aiColor) aiMoveIfNeeded();
  }
  window.addEventListener("resize", () => { fitCanvas(); draw(); });
  start();
})();
</script>
</body>
</html>
